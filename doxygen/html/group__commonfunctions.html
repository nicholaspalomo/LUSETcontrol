<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LUSET Control System: Commonly used functions for target communication.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LUSET Control System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Commonly used functions for target communication.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
INCO variable reading and writing</h2></td></tr>
<tr class="memitem:ga5a35fc7cdfb6037cb755ed8409a8f300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga5a35fc7cdfb6037cb755ed8409a8f300">GetVariable</a> (const char *TargetPath, const char *ItemPath, void *Result, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Length)</td></tr>
<tr class="memdesc:ga5a35fc7cdfb6037cb755ed8409a8f300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote INCO variable read.  <a href="#ga5a35fc7cdfb6037cb755ed8409a8f300">More...</a><br /></td></tr>
<tr class="separator:ga5a35fc7cdfb6037cb755ed8409a8f300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50fba25dcc47ea6f6f54c0141e34563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#gac50fba25dcc47ea6f6f54c0141e34563">PutVariable</a> (const char *TargetPath, const char *ItemPath, const void *Value, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Length)</td></tr>
<tr class="memdesc:gac50fba25dcc47ea6f6f54c0141e34563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote INCO variable write.  <a href="#gac50fba25dcc47ea6f6f54c0141e34563">More...</a><br /></td></tr>
<tr class="separator:gac50fba25dcc47ea6f6f54c0141e34563"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Remote INCO procedure call (RPC)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp66fd2a7eb6c0f71a4c172de68a1997e4"></a>(see also syncasync) </p>
</td></tr>
<tr class="memitem:gaa2b02d8d33d22482538bd936792904b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#gaa2b02d8d33d22482538bd936792904b1">CallProcedure</a> (const char *TargetPath, const char *CallProcedure, double *Result)</td></tr>
<tr class="memdesc:gaa2b02d8d33d22482538bd936792904b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote procedure call.  <a href="#gaa2b02d8d33d22482538bd936792904b1">More...</a><br /></td></tr>
<tr class="separator:gaa2b02d8d33d22482538bd936792904b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9c6b3f22614e8a2072f8c490402131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131">CallProcedureEx</a> (const char *TargetPath, const char *<a class="el" href="group__commonfunctions.html#gaa2b02d8d33d22482538bd936792904b1">CallProcedure</a>, double *SyncResult)</td></tr>
<tr class="memdesc:ga6b9c6b3f22614e8a2072f8c490402131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote procedure call (extended).  <a href="#ga6b9c6b3f22614e8a2072f8c490402131">More...</a><br /></td></tr>
<tr class="separator:ga6b9c6b3f22614e8a2072f8c490402131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea052077eebe514aa0cb1756c595189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga7ea052077eebe514aa0cb1756c595189">CallProcedureExSync</a> (const char *TargetPath, const char *<a class="el" href="group__commonfunctions.html#gaa2b02d8d33d22482538bd936792904b1">CallProcedure</a>, void *Result, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> BufferSize, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> TypeFlags)</td></tr>
<tr class="memdesc:ga7ea052077eebe514aa0cb1756c595189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote procedure call (extended). If the procedure has an asynchronous part, the function will wait for it to complete.  <a href="#ga7ea052077eebe514aa0cb1756c595189">More...</a><br /></td></tr>
<tr class="separator:ga7ea052077eebe514aa0cb1756c595189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293b3f14ba486519c29ac9abfd0471e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga293b3f14ba486519c29ac9abfd0471e3">CallProcedureExResult</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a> Ticket, void *Result, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> BufferSize, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> TypeFlags, char *ResultName, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> ResultNameBufSize)</td></tr>
<tr class="memdesc:ga293b3f14ba486519c29ac9abfd0471e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next asynchronous result (or application error) of a remote procedure call (CallProcedureEx).  <a href="#ga293b3f14ba486519c29ac9abfd0471e3">More...</a><br /></td></tr>
<tr class="separator:ga293b3f14ba486519c29ac9abfd0471e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569a93aeed06c2745365c881be5e7828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga569a93aeed06c2745365c881be5e7828">CallProcedureExResultByName</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a> Ticket, const char *ResultName, void *Result, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> BufferSize, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> TypeFlags)</td></tr>
<tr class="memdesc:ga569a93aeed06c2745365c881be5e7828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next asynchronous named result (or application error) of a remote procedure call (CallProcedureEx).  <a href="#ga569a93aeed06c2745365c881be5e7828">More...</a><br /></td></tr>
<tr class="separator:ga569a93aeed06c2745365c881be5e7828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b55ca711acd0dcc672e5fefe5cff27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga1b55ca711acd0dcc672e5fefe5cff27e">CallProcedureExWait</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a> Ticket, <a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a> TimeoutMs)</td></tr>
<tr class="memdesc:ga1b55ca711acd0dcc672e5fefe5cff27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the asynchronous part of a remote procedure call (CallProcedureEx) to finish (optionally with timeout).  <a href="#ga1b55ca711acd0dcc672e5fefe5cff27e">More...</a><br /></td></tr>
<tr class="separator:ga1b55ca711acd0dcc672e5fefe5cff27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Raw target memory access functions</h2></td></tr>
<tr class="memitem:ga7b0fc73de1e81c47c9ee82db36ea7d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga7b0fc73de1e81c47c9ee82db36ea7d35">PutBlock8</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> DestAddress, const <a class="el" href="indeltypes_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> *Data, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Number)</td></tr>
<tr class="memdesc:ga7b0fc73de1e81c47c9ee82db36ea7d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write raw data in 8 byte chunks to the target.  <a href="#ga7b0fc73de1e81c47c9ee82db36ea7d35">More...</a><br /></td></tr>
<tr class="separator:ga7b0fc73de1e81c47c9ee82db36ea7d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25d23eaf697606036d12356f94fc675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#gab25d23eaf697606036d12356f94fc675">GetBlock8</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> SourceAddress, <a class="el" href="indeltypes_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> *Data, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Number)</td></tr>
<tr class="memdesc:gab25d23eaf697606036d12356f94fc675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads raw data in 8 byte chunks from the target.  <a href="#gab25d23eaf697606036d12356f94fc675">More...</a><br /></td></tr>
<tr class="separator:gab25d23eaf697606036d12356f94fc675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385128fec8e3c887078779f2d8deb0fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga385128fec8e3c887078779f2d8deb0fb">PutBlock16</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> DestAddress, const <a class="el" href="indeltypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *Data, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Number)</td></tr>
<tr class="memdesc:ga385128fec8e3c887078779f2d8deb0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write raw data in 16 bytes chungs to the target.  <a href="#ga385128fec8e3c887078779f2d8deb0fb">More...</a><br /></td></tr>
<tr class="separator:ga385128fec8e3c887078779f2d8deb0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae507b3a868c5004a2142190a48958d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#gae507b3a868c5004a2142190a48958d79">GetBlock16</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> SourceAddress, <a class="el" href="indeltypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *Data, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Number)</td></tr>
<tr class="memdesc:gae507b3a868c5004a2142190a48958d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read raw data in 16 bytes chungs from the target.  <a href="#gae507b3a868c5004a2142190a48958d79">More...</a><br /></td></tr>
<tr class="separator:gae507b3a868c5004a2142190a48958d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c1743c005a868b73e6af8e96eb9d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga51c1743c005a868b73e6af8e96eb9d4e">PutBlock32</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> DestAddress, const <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> *Data, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Number)</td></tr>
<tr class="memdesc:ga51c1743c005a868b73e6af8e96eb9d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write raw data in 32 bytes chungs to the target.  <a href="#ga51c1743c005a868b73e6af8e96eb9d4e">More...</a><br /></td></tr>
<tr class="separator:ga51c1743c005a868b73e6af8e96eb9d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d9fc255f93000f56d0414339ac53e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga25d9fc255f93000f56d0414339ac53e6">GetBlock32</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> SourceAddress, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> *Data, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Number)</td></tr>
<tr class="memdesc:ga25d9fc255f93000f56d0414339ac53e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read raw data in 32 bytes chungs from the target.  <a href="#ga25d9fc255f93000f56d0414339ac53e6">More...</a><br /></td></tr>
<tr class="separator:ga25d9fc255f93000f56d0414339ac53e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa67eff1b4ca61c6c9f1587bafa6e0a54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#gaa67eff1b4ca61c6c9f1587bafa6e0a54">PutBlock64</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> DestAddress, const <a class="el" href="indeltypes_8h.html#ac6afe794ed283c11fb63426a58188e5e">uint64</a> *Data, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Number)</td></tr>
<tr class="memdesc:gaa67eff1b4ca61c6c9f1587bafa6e0a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write raw data in 64 bytes chungs to the target.  <a href="#gaa67eff1b4ca61c6c9f1587bafa6e0a54">More...</a><br /></td></tr>
<tr class="separator:gaa67eff1b4ca61c6c9f1587bafa6e0a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dd1bf74ec3dd28ae6d784db54339802"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga0dd1bf74ec3dd28ae6d784db54339802">GetBlock64</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> SourceAddress, <a class="el" href="indeltypes_8h.html#ac6afe794ed283c11fb63426a58188e5e">uint64</a> *Data, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Number)</td></tr>
<tr class="memdesc:ga0dd1bf74ec3dd28ae6d784db54339802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read raw data in 64 bytes chungs from the target.  <a href="#ga0dd1bf74ec3dd28ae6d784db54339802">More...</a><br /></td></tr>
<tr class="separator:ga0dd1bf74ec3dd28ae6d784db54339802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae156a8a2456bc41746e3452c609ee2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#gae156a8a2456bc41746e3452c609ee2fd">GetBlock8Real</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> SourceAddress, <a class="el" href="indeltypes_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> *Data, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Number)</td></tr>
<tr class="memdesc:gae156a8a2456bc41746e3452c609ee2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For Indel internal use: Read 8 byte chunks of data from target by resolving breakpoints.  <a href="#gae156a8a2456bc41746e3452c609ee2fd">More...</a><br /></td></tr>
<tr class="separator:gae156a8a2456bc41746e3452c609ee2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
INCO error information</h2></td></tr>
<tr class="memitem:ga2ce71629197df864b4ca9121feaff795"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#ga2ce71629197df864b4ca9121feaff795">GetErrorDescription</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Error, char *Description, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Length)</td></tr>
<tr class="memdesc:ga2ce71629197df864b4ca9121feaff795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an INCO error (see also incoreturn_inco_errors) to human readable string.  <a href="#ga2ce71629197df864b4ca9121feaff795">More...</a><br /></td></tr>
<tr class="separator:ga2ce71629197df864b4ca9121feaff795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35d1b67b8052ac2411a9c899141854f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#gae35d1b67b8052ac2411a9c899141854f">GetMcMessage</a> (const char *TargetPath, const char *MessageHandlerPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Error, char *Message, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> Length)</td></tr>
<tr class="separator:gae35d1b67b8052ac2411a9c899141854f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
INCO32 version information</h2></td></tr>
<tr class="memitem:gaae80abf7f7bc82fa98428b67da68a366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__commonfunctions.html#gaae80abf7f7bc82fa98428b67da68a366">GetRevisions</a> (const char *TargetPath, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> *ServerRevision, <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> *DllRevision)</td></tr>
<tr class="memdesc:gaae80abf7f7bc82fa98428b67da68a366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the INCOServer and libinco_32 revisions.  <a href="#gaae80abf7f7bc82fa98428b67da68a366">More...</a><br /></td></tr>
<tr class="separator:gaae80abf7f7bc82fa98428b67da68a366"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa2b02d8d33d22482538bd936792904b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b02d8d33d22482538bd936792904b1">&#9670;&nbsp;</a></span>CallProcedure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI CallProcedure </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>CallProcedure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote procedure call. </p>
<p>Calls procedure <em>ItemPath</em> on target <em>TargetPath</em> and stores the return value, cast to a <code>double</code>, in <em>*Result</em>. </p><dl class="section note"><dt>Note</dt><dd>This function can not properly handle RPCs with asynchronous actions, because it can't wait for its asynchronous part. Use CallProcedureEx if asynchronously executing procedures needs to be called. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">CallProcedure</td><td><a class="el" href="incodefinitions.html#callproceduresyntax">Definition of the CallProcedure(Ex) syntax</a> </td></tr>
    <tr><td class="paramname">Result</td><td>Pointer to a <code>double</code> into which the function writes the value returned by the remote procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="ga6b9c6b3f22614e8a2072f8c490402131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b9c6b3f22614e8a2072f8c490402131">&#9670;&nbsp;</a></span>CallProcedureEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a> WINAPI CallProcedureEx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>CallProcedure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>SyncResult</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote procedure call (extended). </p>
<p>Replaces <a class="el" href="group__commonfunctions.html#gaa2b02d8d33d22482538bd936792904b1" title="Remote procedure call. ">CallProcedure()</a> and adds support for asynchronous procedures. Calls procedure <em>CallProcedure</em> on target <em>TargetPath</em> and stores any return value, cast to a <code>double</code>, in <em>*SyncResult</em>. If the called procedure is asynchronous, this function returns before the asynchronous part of the procedure action has completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">CallProcedure</td><td><a class="el" href="incodefinitions.html#incoitemname">Definition of the ItemPath</a> </td></tr>
    <tr><td class="paramname">SyncResult</td><td>Will be set to the return value of synchronously executing procedures. If NULL is passed (default), the result will be ignored. If <em>CallProcedure</em> is an asynchronous procedure, then <em>SyncResult</em> will not be altered (because such a function does not return any synchronous result). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ticket (negative number) or an error (see page_inco32errors).</dd></dl>
<p>Typical use case: <a class="el" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131" title="Remote procedure call (extended). ">CallProcedureEx()</a> is a perfect replacement for <a class="el" href="group__commonfunctions.html#gaa2b02d8d33d22482538bd936792904b1" title="Remote procedure call. ">CallProcedure()</a>. Therefore, whenever <a class="el" href="group__commonfunctions.html#gaa2b02d8d33d22482538bd936792904b1" title="Remote procedure call. ">CallProcedure()</a> can be used, you may prefer using <a class="el" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131" title="Remote procedure call (extended). ">CallProcedureEx()</a>. In some certain use cases, it may be more straight-forward to use <a class="el" href="group__commonfunctions.html#ga7ea052077eebe514aa0cb1756c595189" title="Remote procedure call (extended). If the procedure has an asynchronous part, the function will wait f...">CallProcedureExSync()</a>.</p>
<dl class="section see"><dt>See also</dt><dd>page_callprocedure_usecase_syncprocedure<br />
 page_callprocedureex_usecase_withoutresults<br />
 page_callprocedureex_usecase_withresults<br />
 page_callprocedureex_usecase_withnamedresults </dd></dl>

</div>
</div>
<a id="ga293b3f14ba486519c29ac9abfd0471e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293b3f14ba486519c29ac9abfd0471e3">&#9670;&nbsp;</a></span>CallProcedureExResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI CallProcedureExResult </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a>&#160;</td>
          <td class="paramname"><em>Ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Result</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>BufferSize</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>TypeFlags</em> = <code><a class="el" href="indeldefs_8h.html#a0f27c7a63f462a5f51c285c85d7a5cac">DF_INCO_TYPE_NUMBER_VALUE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ResultName</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>ResultNameBufSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next asynchronous result (or application error) of a remote procedure call (CallProcedureEx). </p>
<p>Get the next available (means: not yet gotten) result that was returned by the asynchronous part of the procedure that returned <em>Ticket</em>. The function implicitly waits indefinitely for the asynchronous part of the procedure to complete. The caller task will therefore be blocked until the async part has finished. (Note that in the case of process-internal calls (<em>TargetPath</em> is "."), this may be dangerous! See <a class="el" href="group__commonfunctions.html#ga1b55ca711acd0dcc672e5fefe5cff27e" title="Wait for the asynchronous part of a remote procedure call (CallProcedureEx) to finish (optionally wit...">CallProcedureExWait()</a> for details.)</p>
<p>There are two pieces of information that are considered "results", both returned by the asynchronous part of a procedure:</p>
<ul>
<li>Zero or one application error (if any)</li>
<li>Zero or multiple results (or named results)</li>
</ul>
<p>The function is used to get these results. The results can either be get as "number values" cast to a double (by passing <a class="el" href="indeldefs_8h.html#a0f27c7a63f462a5f51c285c85d7a5cac" title="type for &#39;number values&#39; that can be represented by a 64bit floating point number. (such as bool, (u)int8, 16, 32, float and double) ">DF_INCO_TYPE_NUMBER_VALUE</a> for <em>TypeFlags</em>) or as "type safe" values by passing one of the other supported types (see &lt;<a class="el" href="indeldefs_8h.html" title="Various defines related to INCO data types and item characteristics. ">inco_32/indeldefs.h</a>&gt;).</p>
<p>The same result can exactly be read once. This is the case because the result will be removed from the internal buffer after being read. Result values that are not explicitly removed from libinco_32's storage by calling this funtion will eventually be dropped anyway if required to free up space for the results of newer asynchronous procedure calls.</p>
<p>To mention it explictly: To check whether a asynchronous call which does not return any results (such as the CINOSMcRobot::Off command) returned an application error, you need to call this function with <em>Result</em> set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a>. The name of the target to which <em>Ticket</em> belongs. Must exactly match the target name that was passed to the <a class="el" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131" title="Remote procedure call (extended). ">CallProcedureEx()</a> call that produced <em>Ticket</em>, behavior is undefined if different names that refer to the same target are used (with/without server name, with / or \ as separator, aliases, etc.). </td></tr>
    <tr><td class="paramname">Ticket</td><td>The ticket that belongs to the asynchronous part of the procedure of which this function returns the next result. The value of <em>Ticket</em> is usually returned by <a class="el" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131" title="Remote procedure call (extended). ">CallProcedureEx()</a>. </td></tr>
    <tr><td class="paramname">Result</td><td>If not NULL (NULL is default), then the result value will be written to the memory pointed to by <em>Result</em>. Note that the function writes at most <em>BufferSize</em> [Bytes]. If the result is a string, it will always be zero-terminated (even if truncated). Truncation is indicated by returning <a class="el" href="errinco_8h.html#ab5b953eefe05fafee644e883efea54bf" title="the CallProcedure result cannot be written to the buffer passed by the application because the buffer...">ER_INCO_RPC_RESULT_BUFFER_TO_SMALL</a>, and in this case the result will not be removed from storage, so that another call with a sufficiently sized buffer can get its entire value. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>Memory size in [Bytes] where <em>Result</em> points to. The function will at most write this amount of data to <em>Result</em> </td></tr>
    <tr><td class="paramname">TypeFlags</td><td>Any supported type (DF_INCO_TYPE_*) as defined in &lt;<a class="el" href="indeldefs_8h.html" title="Various defines related to INCO data types and item characteristics. ">inco_32/indeldefs.h</a>&gt; can be passed. The function expects the passed type to match the type of the result. Example: If the asynchronous part of an INOS procedure uses pMsg-&gt;AddResult((uint8)77), then the caller must pass <a class="el" href="indeldefs_8h.html#a67196d1983cb3ffd3eead24d2070402e" title="type uint8 ">DF_INCO_TYPE_UINT8</a><br />
There's an exception to the rule above: Any number value (except (u)int64) can automatically be converted to a double by passing <a class="el" href="indeldefs_8h.html#a0f27c7a63f462a5f51c285c85d7a5cac" title="type for &#39;number values&#39; that can be represented by a 64bit floating point number. (such as bool, (u)int8, 16, 32, float and double) ">DF_INCO_TYPE_NUMBER_VALUE</a>.<br />
Alternatively, pass <a class="el" href="indeldefs_8h.html#a2ced59a9816ac78eecb66761e6c56aa8" title="flag to get the type of the result value. result type is expected to be uint32 ">DF_INCO_FLAG_GET_RESULT_TYPE</a> to get the type (as defined in &lt;<a class="el" href="indeldefs_8h.html" title="Various defines related to INCO data types and item characteristics. ">inco_32/indeldefs.h</a>&gt;) of the result, instead of its value. Pass <a class="el" href="indeldefs_8h.html#a38b4f4618d6964e94b19df39dc340af5" title="flag to get the length of the result value. result type is expected to be uint32 ">DF_INCO_FLAG_GET_RESULT_LENGTH</a> to get its length in bytes (mainly used for strings, where it includes the terminating zero). In these two cases, <em>Result</em> must be a pointer to a <code>uint32</code> and <em>BufferSize</em> must be <code>sizeof(uint32)</code> = 4, and the result will (of course) not be removed from the internal buffer and thus the caller can get the actual result by a subsequent call to this function. </td></tr>
    <tr><td class="paramname">ResultName</td><td>[out] Optional pointer to a string buffer that will take the result name, if any. The name will not be set if the pointer is NULL (default). </td></tr>
    <tr><td class="paramname">ResultNameBufSize</td><td>Buffer size (= string length + 1) in [Bytes] of the available buffer <em>ResultName</em>. The function will at most write <em>ResultNameBufSize</em> - 1 Bytes of the result name and will ensure that the string in <em>ResultName</em> will be zero-terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success: <a class="el" href="errinco_8h.html#ac806a12a2f08c29e901360403c9e239e" title="ok ">ER_INCO_NO_ERROR</a> </dd>
<dd>
If the procedure returned no results and no application error, only an indication that it is done (only for calls to external targets): <a class="el" href="errinco_8h.html#a8d818cdfabc610635069cde0387cf43a" title="The function didn&#39;t return any result. ">ER_INCO_RPC_NO_RETURN_VALUE</a> </dd>
<dd>
If all results (or completion indication or application error) have already been retrieved or were dropped to free up space because they were not retrieved in time (or no results were returned for process-internal calls): <a class="el" href="errinco_8h.html#a0cb9cbd56f7aa78ac186c79f03aa9c32" title="Ticket is either invalid, the results have already been got or it&#39;s result has already been purged fr...">ER_INCO_RPC_UNKNOWN_TICKET</a> </dd>
<dd>
On INCO failure: Any INCO error, as defined in &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; </dd>
<dd>
If the procedure was interrupted by a target reset: <a class="el" href="errinco_8h.html#a7d44ee063ff87c44112580cc6042872d" title="asynchronous procedure was interrupted by target reset ">ER_INCO_RPC_INTERRUPTED</a>. No results are available in that case. </dd>
<dd>
Application error: If the asynchronous part of the procedure encountered any problem, the application error will be returned on the first call to this function for a given ticket. See incoreturn_application_erros. Additional results may still be available after that.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>page_callprocedure_usecase_syncprocedure<br />
 page_callprocedureex_usecase_withoutresults<br />
 page_callprocedureex_usecase_withresults<br />
 page_callprocedureex_usecase_withnamedresults<br />
 syncasyncretval in syncasync </dd></dl>

</div>
</div>
<a id="ga569a93aeed06c2745365c881be5e7828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga569a93aeed06c2745365c881be5e7828">&#9670;&nbsp;</a></span>CallProcedureExResultByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI CallProcedureExResultByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a>&#160;</td>
          <td class="paramname"><em>Ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ResultName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>BufferSize</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>TypeFlags</em> = <code><a class="el" href="indeldefs_8h.html#a0f27c7a63f462a5f51c285c85d7a5cac">DF_INCO_TYPE_NUMBER_VALUE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next asynchronous named result (or application error) of a remote procedure call (CallProcedureEx). </p>
<p>This function is very similar to <a class="el" href="group__commonfunctions.html#ga293b3f14ba486519c29ac9abfd0471e3" title="Get the next asynchronous result (or application error) of a remote procedure call (CallProcedureEx)...">CallProcedureExResult()</a>. The only difference is that this function does not return the 'next result' but the result with the name referred to by ResultName. Similar to <a class="el" href="group__commonfunctions.html#ga293b3f14ba486519c29ac9abfd0471e3" title="Get the next asynchronous result (or application error) of a remote procedure call (CallProcedureEx)...">CallProcedureExResult()</a>, once a certain result has been read, it can't be read again. This is true independently of whether you use <a class="el" href="group__commonfunctions.html#ga293b3f14ba486519c29ac9abfd0471e3" title="Get the next asynchronous result (or application error) of a remote procedure call (CallProcedureEx)...">CallProcedureExResult()</a> or <a class="el" href="group__commonfunctions.html#ga569a93aeed06c2745365c881be5e7828" title="Get the next asynchronous named result (or application error) of a remote procedure call (CallProcedu...">CallProcedureExResultByName()</a> the second time.</p>
<p>Lets make an example to clarify this: Assume there are three results for a certain ticket. Assume they have the name "Result1", "Result2" and "Result3". If the caller performs the following code (pseudocode): </p><div class="fragment"><div class="line"><a class="code" href="group__commonfunctions.html#ga569a93aeed06c2745365c881be5e7828">CallProcedureExResultByName</a>(..., <span class="stringliteral">&quot;Result2&quot;</span>, ...);</div></div><!-- fragment --><p> Then the following is true: </p><div class="fragment"><div class="line"><a class="code" href="group__commonfunctions.html#ga293b3f14ba486519c29ac9abfd0471e3">CallProcedureExResult</a>(...); <span class="comment">// return the value of &quot;Result1&quot;</span></div><div class="line"><a class="code" href="group__commonfunctions.html#ga293b3f14ba486519c29ac9abfd0471e3">CallProcedureExResult</a>(...); <span class="comment">// return the value of &quot;Result3&quot;</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">ResultName</td><td>Zero terminated string of the result name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>page_callprocedure_usecase_syncprocedure<br />
 page_callprocedureex_usecase_withoutresults<br />
 page_callprocedureex_usecase_withresults<br />
 page_callprocedureex_usecase_withnamedresults </dd></dl>

</div>
</div>
<a id="ga7ea052077eebe514aa0cb1756c595189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea052077eebe514aa0cb1756c595189">&#9670;&nbsp;</a></span>CallProcedureExSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI CallProcedureExSync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>CallProcedure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Result</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>BufferSize</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>TypeFlags</em> = <code><a class="el" href="indeldefs_8h.html#a0f27c7a63f462a5f51c285c85d7a5cac">DF_INCO_TYPE_NUMBER_VALUE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote procedure call (extended). If the procedure has an asynchronous part, the function will wait for it to complete. </p>
<p>Calls procedure <em>CallProcedure</em> on target <em>TargetPath</em>. If the called procedure is asynchronous, this function implicitly waits for the asynchronous part of the procedure action to complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">CallProcedure</td><td><a class="el" href="incodefinitions.html#incoitemname">Definition of the ItemPath</a> </td></tr>
    <tr><td class="paramname">Result</td><td>If not NULL (default) and the procedure has no asynchronous part, then the synchronous result value will be set and <em>Result</em> is expected to be of type <code>double*</code> (and accordingly <em>BufferSize</em> = <code>sizeof(double)</code> = 8 and <em>TypeFlags</em> = <a class="el" href="indeldefs_8h.html#a0f27c7a63f462a5f51c285c85d7a5cac" title="type for &#39;number values&#39; that can be represented by a 64bit floating point number. (such as bool, (u)int8, 16, 32, float and double) ">DF_INCO_TYPE_NUMBER_VALUE</a>). If the procedure has an asynchronous part and the asynchronous part returns at least one result, this function will return the first result and write it to <em>Result</em> (if it's not NULL). Note that all results (except the first one) are lost, because the caller doesn't get the ticket. Use <a class="el" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131" title="Remote procedure call (extended). ">CallProcedureEx()</a> if you want to get more than one result.</td></tr>
  </table>
  </dd>
</dl>
<p>Typical use case: Using <a class="el" href="group__commonfunctions.html#ga7ea052077eebe514aa0cb1756c595189" title="Remote procedure call (extended). If the procedure has an asynchronous part, the function will wait f...">CallProcedureExSync()</a> makes sense if the programmer knows that the remote procedure does either have no asynchronous part, or it has an asynchronous part and returns zero or one result.</p>
<p>Note that for process-internal calls (<em>TargetPath</em> = "."), the included waiting may carry a risk of deadlocking - see <a class="el" href="group__commonfunctions.html#ga1b55ca711acd0dcc672e5fefe5cff27e" title="Wait for the asynchronous part of a remote procedure call (CallProcedureEx) to finish (optionally wit...">CallProcedureExWait()</a> for details.</p>
<dl class="section see"><dt>See also</dt><dd>page_callprocedure_usecase_syncprocedure for a code exmaple. </dd></dl>

</div>
</div>
<a id="ga1b55ca711acd0dcc672e5fefe5cff27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b55ca711acd0dcc672e5fefe5cff27e">&#9670;&nbsp;</a></span>CallProcedureExWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI CallProcedureExWait </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a>&#160;</td>
          <td class="paramname"><em>Ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#ac44d0188f4f50fd9b03031c1a06bd0a9">int32</a>&#160;</td>
          <td class="paramname"><em>TimeoutMs</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the asynchronous part of a remote procedure call (CallProcedureEx) to finish (optionally with timeout). </p>
<p>This function is usually used waiting for the asynchronous part shouldn't be done infinitely. If waiting infinitely is ok, it's slightly more efficiently to use CallProcedureExResult directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a>. The name of the target to which <em>Ticket</em> belongs. Must exactly match the target name that was passed to the <a class="el" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131" title="Remote procedure call (extended). ">CallProcedureEx()</a> call that produced <em>Ticket</em>, behavior is undefined if different names that refer to the same target are used (with/without server name, with / or \ as separator, aliases, etc.). </td></tr>
    <tr><td class="paramname">Ticket</td><td>Should be a valid ticket previously returned by <a class="el" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131" title="Remote procedure call (extended). ">CallProcedureEx()</a> </td></tr>
    <tr><td class="paramname">TimeoutMs</td><td>Timeout used while waiting for the asynchronous part in [ms]. If -1 is passed, then the call will block forever, until the asynchronous part completed, or an error occurs. If 0 is passed, then the function will not wait but instead just check whether the asynchronous part has already completed and will return immediately. This can be used for "polling". Note that, depending on the used OS (Windows vs. Linux), the smallest applicable timeout may be around 10ms. Thus, even if you pass 1ms here, it'll probably result in 10ms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="errinco_8h.html#ac806a12a2f08c29e901360403c9e239e" title="ok ">ER_INCO_NO_ERROR</a> if the async part referred to by <em>Ticket</em> has completed, or the INCOServer has detected that it was interrupted by a target reset (check for return value <a class="el" href="errinco_8h.html#a7d44ee063ff87c44112580cc6042872d" title="asynchronous procedure was interrupted by target reset ">ER_INCO_RPC_INTERRUPTED</a> from <a class="el" href="group__commonfunctions.html#ga293b3f14ba486519c29ac9abfd0471e3" title="Get the next asynchronous result (or application error) of a remote procedure call (CallProcedureEx)...">CallProcedureExResult()</a> to detect the latter situation). </dd>
<dd>
<a class="el" href="errinco_8h.html#a31a88ed7f6d5320d8e7c7f82eca0abd5" title="waiting for the asynchronous part of the callprocedure timed out ">ER_INCO_RPC_WAIT_TIMEOUT</a> if the async part has not yet completed and waiting for it has timed out (or there was no waiting because <em>TimeoutMs</em> = 0). </dd>
<dd>
An INCO error code (see &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt;) in case of INCO communication problems (e.g. INCOServer not running). Note that this function does not return application errors, therefore, it can't be used to check whether an async part has completed with success or error. Instead, it can just be used to check whether the async part has finished. </dd>
<dd>
This function does NOT return application errors and reply codes (i.e. the errors set by MsgError &amp; co in McRobot). Always use CallProcedureExResult for that purpose.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>page_callprocedure_usecase_syncprocedure<br />
 page_callprocedureex_usecase_withoutresults<br />
 page_callprocedureex_usecase_withresults<br />
 page_callprocedureex_usecase_withnamedresults</dd></dl>
<p>Typical use case: <a class="el" href="group__commonfunctions.html#ga1b55ca711acd0dcc672e5fefe5cff27e" title="Wait for the asynchronous part of a remote procedure call (CallProcedureEx) to finish (optionally wit...">CallProcedureExWait()</a> is usually only used if the programmer wants to wait with a timeout. For all other cases, CallProcedureExResult is the preferred way to wait for the completion for the asynchronous procedure becuase it does not only wait, but also return any occurred application error.</p>
<p>No guarantees are made about the accuracy of the timeout duration. The given number is a lower bound, but the total execution time of the function may be longer than that, since various parts of its internal implementation are not counted against the total.</p>
<p>If the called procedure is not in the same process, but the call goes to an external target via INCOServer (i.e. <em>TargetPath</em> is not <code>"."</code>), this function must only be called by the same thread that made the original <a class="el" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131" title="Remote procedure call (extended). ">CallProcedureEx()</a> call. For calls within a process, no such restriction exists and any number of threads can wait.</p>
<p>For process-internal calls, be careful when using this function, particularly with infinite timeout: Make sure that by waiting, you are not inadvertently blocking the action that you are waiting for, causing a deadlock. In particular, this can happen in the following two situations:</p><ul>
<li>The asynchronous action waited for is queued to be executed in the same thread that calls <a class="el" href="group__commonfunctions.html#ga1b55ca711acd0dcc672e5fefe5cff27e" title="Wait for the asynchronous part of a remote procedure call (CallProcedureEx) to finish (optionally wit...">CallProcedureExWait()</a>. Putting that thread to sleep now means that it never gets to attend its queue.</li>
<li>The thread that calls <a class="el" href="group__commonfunctions.html#ga1b55ca711acd0dcc672e5fefe5cff27e" title="Wait for the asynchronous part of a remote procedure call (CallProcedureEx) to finish (optionally wit...">CallProcedureExWait()</a> is holding some lock that the thread running the asynchronous action needs to acquire before or during the action.</li>
</ul>
<p>Within another INCO procedure in particular, a better solution than </p><div class="fragment"><div class="line"><a class="code" href="group__commonfunctions.html#ga1b55ca711acd0dcc672e5fefe5cff27e">CallProcedureExWait</a>(<span class="stringliteral">&quot;.&quot;</span>, <a class="code" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131">CallProcedureEx</a>(<span class="stringliteral">&quot;.&quot;</span>, <span class="stringliteral">&quot;Cmd.Proc()&quot;</span>));</div></div><!-- fragment --><p> is usually </p><div class="fragment"><div class="line"><a class="code" href="inco__32_8h.html#a6777f042962e0af6ecd414a5bf409343">ReturnAsyncCallTicketAfterCallHasFinished</a>(</div><div class="line">    <a class="code" href="inco__32_8h.html#a4d9e4e45113399ec8110d78e27e16faf">CheckoutAsyncCallTicket</a>(),</div><div class="line">    <a class="code" href="group__commonfunctions.html#ga6b9c6b3f22614e8a2072f8c490402131">CallProcedureEx</a>(<span class="stringliteral">&quot;.&quot;</span>, <span class="stringliteral">&quot;Cmd.Proc()&quot;</span>)</div><div class="line">);</div></div><!-- fragment --><p>See also syncasyncwithin </p>

</div>
</div>
<a id="gae507b3a868c5004a2142190a48958d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae507b3a868c5004a2142190a48958d79">&#9670;&nbsp;</a></span>GetBlock16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI GetBlock16 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>SourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read raw data in 16 bytes chungs from the target. </p>
<p>Same as <a class="el" href="group__commonfunctions.html#gab25d23eaf697606036d12356f94fc675" title="Reads raw data in 8 byte chunks from the target. ">GetBlock8</a>, but reads <em>Number</em> times 16 byte of data. This function automatically changes endianness of the data if the target and host endiannes are different. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">SourceAddress</td><td>The 32 bit memory address (target side) </td></tr>
    <tr><td class="paramname">Data</td><td>Pointer to the data to which the read data should be written </td></tr>
    <tr><td class="paramname">Number</td><td>Number of 16 byte chunks to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="ga25d9fc255f93000f56d0414339ac53e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d9fc255f93000f56d0414339ac53e6">&#9670;&nbsp;</a></span>GetBlock32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI GetBlock32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>SourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> *&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read raw data in 32 bytes chungs from the target. </p>
<p>Same as <a class="el" href="group__commonfunctions.html#gab25d23eaf697606036d12356f94fc675" title="Reads raw data in 8 byte chunks from the target. ">GetBlock8</a>, but reads <em>Number</em> times 32 byte of data. This function automatically changes endianness of the data if the target and host endiannes are different. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">SourceAddress</td><td>The 32 bit memory address (target side) </td></tr>
    <tr><td class="paramname">Data</td><td>Pointer to the data to which the read data should be written </td></tr>
    <tr><td class="paramname">Number</td><td>Number of 32 byte chunks to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="ga0dd1bf74ec3dd28ae6d784db54339802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dd1bf74ec3dd28ae6d784db54339802">&#9670;&nbsp;</a></span>GetBlock64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI GetBlock64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>SourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#ac6afe794ed283c11fb63426a58188e5e">uint64</a> *&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read raw data in 64 bytes chungs from the target. </p>
<p>Same as <a class="el" href="group__commonfunctions.html#gab25d23eaf697606036d12356f94fc675" title="Reads raw data in 8 byte chunks from the target. ">GetBlock8</a>, but reads <em>Number</em> times 64 byte of data. This function automatically changes endianness of the data if the target and host endiannes are different. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">SourceAddress</td><td>The 32 bit memory address (target side) </td></tr>
    <tr><td class="paramname">Data</td><td>Pointer to the data to which the read data should be written </td></tr>
    <tr><td class="paramname">Number</td><td>Number of 64 byte chunks to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="gab25d23eaf697606036d12356f94fc675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab25d23eaf697606036d12356f94fc675">&#9670;&nbsp;</a></span>GetBlock8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI GetBlock8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>SourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> *&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads raw data in 8 byte chunks from the target. </p>
<p>Reads <em>Number</em> of bytes of data from the memory at <em>SourceAddress</em> in the INCO target <em>TargetPath</em> and copies that data into the buffer pointed to by <em>Data</em>. The function assumes that <em>Data</em> is at least as big as <em>Number</em> bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">SourceAddress</td><td>The 32 bit memory address (target side) </td></tr>
    <tr><td class="paramname">Data</td><td>Pointer to the data to which the read data should be written </td></tr>
    <tr><td class="paramname">Number</td><td>Number of 8 byte chunks to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="gae156a8a2456bc41746e3452c609ee2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae156a8a2456bc41746e3452c609ee2fd">&#9670;&nbsp;</a></span>GetBlock8Real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI GetBlock8Real </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>SourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> *&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For Indel internal use: Read 8 byte chunks of data from target by resolving breakpoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">SourceAddress</td><td>The 32 bit memory address (target side) </td></tr>
    <tr><td class="paramname">Data</td><td>Pointer to the data to which the read data should be written </td></tr>
    <tr><td class="paramname">Number</td><td>Number of 8 byte chunks to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="ga2ce71629197df864b4ca9121feaff795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce71629197df864b4ca9121feaff795">&#9670;&nbsp;</a></span>GetErrorDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI GetErrorDescription </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an INCO error (see also incoreturn_inco_errors) to human readable string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a>. The name of the slave/target for which a previous call failed </td></tr>
    <tr><td class="paramname">Error</td><td>The error code that was previously returned by an INCO function, such as <a class="el" href="group__commonfunctions.html#gaa2b02d8d33d22482538bd936792904b1" title="Remote procedure call. ">CallProcedure()</a>, <a class="el" href="group__commonfunctions.html#ga5a35fc7cdfb6037cb755ed8409a8f300" title="Remote INCO variable read. ">GetVariable()</a>, <a class="el" href="group__commonfunctions.html#gac50fba25dcc47ea6f6f54c0141e34563" title="Remote INCO variable write. ">PutVariable()</a>, etc. </td></tr>
    <tr><td class="paramname">Description</td><td>If <em>Length</em> is unequal 0, this parameter should point to a string buffer. The function copies the error text into that buffer.<br />
 If <em>Length</em> is 0, then <em>Description</em> should point to a long. </td></tr>
    <tr><td class="paramname">Length</td><td>If <em>Length</em> is unequal 0, then its value is the maximum allowed string length (not buffer size!). Internally, the function call 'strncpy(Description, {TheErrorText}, Length);'.<br />
 If <em>Length</em> is 0, then the function assumes that <em>Description</em> points to a 'long' value and the function writes the required buffer size (not string length!) to it.</td></tr>
  </table>
  </dd>
</dl>
<p>Trivial example (complicated): </p><div class="fragment"><div class="line"><span class="comment">// Create a buffer that&#39;s huge enough:</span></div><div class="line"><span class="keywordtype">char</span> cErrorMsg[512];</div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="group__commonfunctions.html#ga2ce71629197df864b4ca9121feaff795">GetErrorDescription</a>(<span class="stringliteral">&quot;TargetName&quot;</span>, uError, cErrorMsg, <span class="keyword">sizeof</span>(cErrorMsg)-1) == <a class="code" href="errinco_8h.html#ac806a12a2f08c29e901360403c9e239e">ER_INCO_NO_ERROR</a> ) {</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Error occurred: &quot;</span> &lt;&lt; cErrorMsg &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>Example (complicated): </p><div class="fragment"><div class="line"><span class="comment">// Get the required buffer size:</span></div><div class="line"><span class="keywordtype">long</span> iRequiredBufferSize;</div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="group__commonfunctions.html#ga2ce71629197df864b4ca9121feaff795">GetErrorDescription</a>(<span class="stringliteral">&quot;TargetName&quot;</span>, uError, &amp;iRequiredBufferSize, 0) == <a class="code" href="errinco_8h.html#ac806a12a2f08c29e901360403c9e239e">ER_INCO_NO_ERROR</a> ) {</div><div class="line">    <span class="keywordtype">char</span> pErrorText = <span class="keyword">new</span> <span class="keywordtype">char</span>[iRequiredBufferSize];</div><div class="line">    <span class="comment">// get the actual error text:</span></div><div class="line">    <span class="keywordflow">if</span>( <a class="code" href="group__commonfunctions.html#ga2ce71629197df864b4ca9121feaff795">GetErrorDescription</a>(<span class="stringliteral">&quot;TargetName&quot;</span>, uError, pErrorText, iRequiredBufferSize-1) == <a class="code" href="errinco_8h.html#ac806a12a2f08c29e901360403c9e239e">ER_INCO_NO_ERROR</a> ) {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Error occurred: &quot;</span> &lt;&lt; pErrorText &lt;&lt; endl;</div><div class="line">        <span class="keyword">delete</span> [] pErrorText;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="gae35d1b67b8052ac2411a9c899141854f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae35d1b67b8052ac2411a9c899141854f">&#9670;&nbsp;</a></span>GetMcMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI GetMcMessage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>MessageHandlerPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the error message of a McRobot message container. Usually, a McRobot based machine has 1 message handler, often located at "Machine.Msg" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MessagePath</td><td>INCO Path to the message handler. Usually, this path is "Machine.Msg" </td></tr>
    <tr><td class="paramname">Error</td><td>The INCO error code as returned from e.g. CallProcedure. Note that this function will care about 'reply codes' by masking them off the error). If the error is not a "McRobot error code" (McRobot errors have the bits set defined by ER_APPERROR_BASE (0x40000000) or ER_APPERROR_CUSTOMER (0x80000000)), this function returns ER_INCO_VAR_NOT_FOUND. </td></tr>
    <tr><td class="paramname">Message</td><td>Pointer to the buffer were the message text will be copied </td></tr>
    <tr><td class="paramname">Length</td><td>Size of the buffer defined by Message in [Bytes] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Technically, this function tries to resolve the error passed by param "Error" by accessing the target with GetVariable. Therefore, this function may reutrn any error that may occur by a GetVariable. </dd></dl>

</div>
</div>
<a id="gaae80abf7f7bc82fa98428b67da68a366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae80abf7f7bc82fa98428b67da68a366">&#9670;&nbsp;</a></span>GetRevisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI GetRevisions </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> *&#160;</td>
          <td class="paramname"><em>ServerRevision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> *&#160;</td>
          <td class="paramname"><em>DllRevision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the INCOServer and libinco_32 revisions. </p>

</div>
</div>
<a id="ga5a35fc7cdfb6037cb755ed8409a8f300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a35fc7cdfb6037cb755ed8409a8f300">&#9670;&nbsp;</a></span>GetVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI GetVariable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ItemPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote INCO variable read. </p>
<p>Reads variable <em>ItemPath</em> on target <em>TargetPath</em> and stores the return value, cast to a <code>double</code> if <em>Length</em> is 0 or cast to a sequence of <code>char</code>s if length is unequal 0, in <em>*Result</em>. If the variable must be read asynchronously, this function waits for the asynchronous reading to complete. Caution: this waiting means that asynchronous variable getters must be implemented carefully to avoid deadlocks! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">ItemPath</td><td><a class="el" href="incodefinitions.html#incoitemname">Definition of the ItemPath</a> </td></tr>
    <tr><td class="paramname">Result</td><td>Pointer to the buffer to which the value will be written to. Must be a <code>double</code> in <em>Length</em> is 0 or a <code>char*</code> of at least <em>Length</em> size. </td></tr>
    <tr><td class="paramname">Length</td><td>A value of 0 means that a <code>double</code> (or any other number item) should be read. A value &gt; 0 means to read a data buffer (usually a char*) of size <em>Length</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors).</dd></dl>
<p>See also syncasync </p>

</div>
</div>
<a id="ga385128fec8e3c887078779f2d8deb0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga385128fec8e3c887078779f2d8deb0fb">&#9670;&nbsp;</a></span>PutBlock16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI PutBlock16 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>DestAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indeltypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write raw data in 16 bytes chungs to the target. </p>
<p>Same as <a class="el" href="group__commonfunctions.html#ga7b0fc73de1e81c47c9ee82db36ea7d35" title="Write raw data in 8 byte chunks to the target. ">PutBlock8</a>, but writes <em>Number</em> times 16 byte of data. This function automatically changes endianness of the data if the target and host endiannes are different.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">DestAddress</td><td>The 32 bit memory address (target side) </td></tr>
    <tr><td class="paramname">Data</td><td>Pointer to the data that should be written to the target </td></tr>
    <tr><td class="paramname">Number</td><td>Number of 16 byte chunks to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="ga51c1743c005a868b73e6af8e96eb9d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c1743c005a868b73e6af8e96eb9d4e">&#9670;&nbsp;</a></span>PutBlock32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI PutBlock32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>DestAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> *&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write raw data in 32 bytes chungs to the target. </p>
<p>Same as <a class="el" href="group__commonfunctions.html#ga7b0fc73de1e81c47c9ee82db36ea7d35" title="Write raw data in 8 byte chunks to the target. ">PutBlock8</a>, but writes <em>Number</em> times 32 byte of data. This function automatically changes endianness of the data if the target and host endiannes are different. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">DestAddress</td><td>The 32 bit memory address (target side) </td></tr>
    <tr><td class="paramname">Data</td><td>Pointer to the data that should be written to the target </td></tr>
    <tr><td class="paramname">Number</td><td>Number of 32 byte chunks to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="gaa67eff1b4ca61c6c9f1587bafa6e0a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa67eff1b4ca61c6c9f1587bafa6e0a54">&#9670;&nbsp;</a></span>PutBlock64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI PutBlock64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>DestAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indeltypes_8h.html#ac6afe794ed283c11fb63426a58188e5e">uint64</a> *&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write raw data in 64 bytes chungs to the target. </p>
<p>Same as <a class="el" href="group__commonfunctions.html#ga7b0fc73de1e81c47c9ee82db36ea7d35" title="Write raw data in 8 byte chunks to the target. ">PutBlock8</a>, but writes <em>Number</em> times 64 byte of data. This function automatically changes endianness of the data if the target and host endiannes are different. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">DestAddress</td><td>The 32 bit memory address (target side) </td></tr>
    <tr><td class="paramname">Data</td><td>Pointer to the data that should be written to the target </td></tr>
    <tr><td class="paramname">Number</td><td>Number of 64 byte chunks to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="ga7b0fc73de1e81c47c9ee82db36ea7d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b0fc73de1e81c47c9ee82db36ea7d35">&#9670;&nbsp;</a></span>PutBlock8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI PutBlock8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>DestAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indeltypes_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> *&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write raw data in 8 byte chunks to the target. </p>
<p>Writes <em>Number</em> bytes of the data pointed to by <em>Data</em> to the address <em>DestAddress</em> in the INCO target <em>TargetPath</em>. <em>DestAddress</em> may by any address available at the target. Note that the target does usually allow arbitrary memory writes - even if modifying the data will cause target crashes. Therefore, using this function is only recommended in rare cases. The function assumes that <em>Data</em> is at least as big as <em>Number</em> bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">DestAddress</td><td>The 32 bit memory address (target side) </td></tr>
    <tr><td class="paramname">Data</td><td>Pointer to the data that should be written to the target </td></tr>
    <tr><td class="paramname">Number</td><td>Number of 8 byte chunks to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
<a id="gac50fba25dcc47ea6f6f54c0141e34563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac50fba25dcc47ea6f6f54c0141e34563">&#9670;&nbsp;</a></span>PutVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inco__32_8h.html#a09505cad5bbb66fc36750a4fbca0444b">INCO32_EXPORT</a> <a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> WINAPI PutVariable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>TargetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ItemPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indeltypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>Length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote INCO variable write. </p>
<p>Writes the data pointed to by <em>Value</em> to the INCO variable <em>ItemPath</em> on target <em>TargetPath</em>. The data type to which <em>Value</em> points to depends on the value of <em>Length</em> and must either be a <code>char*</code> (<em>Length</em> &gt; 0) or a <code>double</code> (<em>Length</em> 0). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetPath</td><td><a class="el" href="incodefinitions.html#targetpath">Definition of the TargetPath</a> </td></tr>
    <tr><td class="paramname">ItemPath</td><td><a class="el" href="incodefinitions.html#incoitemname">Definition of the ItemPath</a> </td></tr>
    <tr><td class="paramname">Value</td><td>Pointer to the value that should be written. If <em>Length</em> is 0, <em>Value</em> is expected to point to a <code>double</code>. Otherwise a <code>char*</code>. </td></tr>
    <tr><td class="paramname">Length</td><td>If 0, then <em>Value</em> must point to a <code>double</code>. If &gt; 0, this function writes as many bytes as defined by <em>Length</em> to <em>ItemPath</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code from &lt;<a class="el" href="errinco_8h.html" title="Error handling related defines. ">inco_32/errinco.h</a>&gt; (see page_inco32errors). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
